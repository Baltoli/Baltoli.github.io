{
    "docs": [
        {
            "location": "/", 
            "text": "TESLA\n\n\nTESLA allows you to make \ntemporal assertions\n about your programs. Instead of\nbeing limited to its current state, you can make assertions about its \npast\n and\n\nfuture\n as well\nletting you write safer programs as naturally as possible.\n\n\nWith TESLA, you can make assertions like \nThe function \naccess_control_check\n\nreturned \n0\n before reading a file\n or \nThe structure field \nlock-\nheld\n is set\nto \nfalse\n in the future\n. In normal programs, these properties are often\nasserted informally or not at all. With TESLA, they can be checked automatically\nat compile- or run-time.\n\n\nExamples\n\n\nchar *read_sensitive_data() {\n  TESLA_WITHIN(main, previously(\n    access_control_check() == 0\n  ));\n\n  char *data;\n  // perform sensitive data access\n  return data;\n}\n\n\n\n\nvoid critical_section_begin(lock_t *lock) {\n  TESLA_WITHIN(main, eventually(\n    lock-\nheld = false\n  ));\n\n  // do locked critical section work\n}\n\n\n\n\nSetup\n\n\nSee the \ninstallation guide\n for instructions on getting set up\nwith TESLA. Once you\nve got it up and running, the \nprogramming\nguide\n walks you through how to write a program with TESLA\nassertions.\n\n\nPublications\n\n\n\n\nTESLA: Temporally Enhanced System Logic Assertions\n\n\nStatic Analysis for TESLA (\nupcoming\n)", 
            "title": "Home"
        }, 
        {
            "location": "/#tesla", 
            "text": "TESLA allows you to make  temporal assertions  about your programs. Instead of\nbeing limited to its current state, you can make assertions about its  past  and future  as well letting you write safer programs as naturally as possible.  With TESLA, you can make assertions like  The function  access_control_check \nreturned  0  before reading a file  or  The structure field  lock- held  is set\nto  false  in the future . In normal programs, these properties are often\nasserted informally or not at all. With TESLA, they can be checked automatically\nat compile- or run-time.", 
            "title": "TESLA"
        }, 
        {
            "location": "/#examples", 
            "text": "char *read_sensitive_data() {\n  TESLA_WITHIN(main, previously(\n    access_control_check() == 0\n  ));\n\n  char *data;\n  // perform sensitive data access\n  return data;\n}  void critical_section_begin(lock_t *lock) {\n  TESLA_WITHIN(main, eventually(\n    lock- held = false\n  ));\n\n  // do locked critical section work\n}", 
            "title": "Examples"
        }, 
        {
            "location": "/#setup", 
            "text": "See the  installation guide  for instructions on getting set up\nwith TESLA. Once you ve got it up and running, the  programming\nguide  walks you through how to write a program with TESLA\nassertions.", 
            "title": "Setup"
        }, 
        {
            "location": "/#publications", 
            "text": "TESLA: Temporally Enhanced System Logic Assertions  Static Analysis for TESLA ( upcoming )", 
            "title": "Publications"
        }, 
        {
            "location": "/installation/", 
            "text": "Installing TESLA\n\n\nIf you don\nt need to work on the TESLA source, you can install it from Homebrew:\n\n\nbrew install baltoli/tesla/tesla\n\n\n\n\nDependencies\n\n\nTo build TESLA, you need:\n\n\n\n\nBuild system:\n\n\nCMake\n\n\nA C++14 compatible compiler (GCC 5+ or Clang 3.4+)\n\n\n\n\n\n\nTESLA dependencies:\n\n\nLLVM 4.0\n\n\nProtocol Buffers\n\n\nZ3\n\n\n\n\n\n\n\n\nThe TESLA dependencies don\nt need to be installed from source\nyou can get them\nfrom a package manager if that\ns easier.\n\n\nBuild Instructions\n\n\nOnce you\nve installed the dependencies, you can build TESLA as follows:\n\n\ngit clone \nhttp://github.com/cadets/tesla-static-analysis\n\ncd tesla-static-analysis\n\nmkdir build\ncd build\n\ncmake -D LLVM_DIR=\npath/to/llvm\n ..\nmake\nmake install\n\n\n\n\nThe CMake option \nLLVM_DIR\n should point to the directory where LLVM has\ninstalled its CMake files. This will typically be the \nlib/cmake/llvm/\n\nsubdirectory of the LLVM install directory.\n\n\nTo install TESLA to a non-standard location, set \nCMAKE_INSTALL_PREFIX\n and run\n\nmake install\n.\n\n\nOnce you have TESLA installed, you should be able to run \ntesla\n to see a list\nof the available toolchain commands. The next step is to \nwrite some TESLA\nassertions\n.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installing-tesla", 
            "text": "If you don t need to work on the TESLA source, you can install it from Homebrew:  brew install baltoli/tesla/tesla", 
            "title": "Installing TESLA"
        }, 
        {
            "location": "/installation/#dependencies", 
            "text": "To build TESLA, you need:   Build system:  CMake  A C++14 compatible compiler (GCC 5+ or Clang 3.4+)    TESLA dependencies:  LLVM 4.0  Protocol Buffers  Z3     The TESLA dependencies don t need to be installed from source you can get them\nfrom a package manager if that s easier.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/installation/#build-instructions", 
            "text": "Once you ve installed the dependencies, you can build TESLA as follows:  git clone  http://github.com/cadets/tesla-static-analysis \ncd tesla-static-analysis\n\nmkdir build\ncd build\n\ncmake -D LLVM_DIR= path/to/llvm  ..\nmake\nmake install  The CMake option  LLVM_DIR  should point to the directory where LLVM has\ninstalled its CMake files. This will typically be the  lib/cmake/llvm/ \nsubdirectory of the LLVM install directory.  To install TESLA to a non-standard location, set  CMAKE_INSTALL_PREFIX  and run make install .  Once you have TESLA installed, you should be able to run  tesla  to see a list\nof the available toolchain commands. The next step is to  write some TESLA\nassertions .", 
            "title": "Build Instructions"
        }, 
        {
            "location": "/programming/", 
            "text": "Programming with TESLA\n\n\nThis page walks you through how to use TESLA. It explains how TESLA is\nimplemented (and some associated terminology), how to use the toolchain, then\nhow to start writing useful assertions about your programs.\n\n\nTESLA Basics\n\n\nTESLA is implemented as a set of tools that extend the traditional C compilation\nprocess. To write TESLA assertions, you need to add these tools to your\nbuild system and generate the TESLA intermediate products.\n\n\nIntermediate Products\n\n\nTo use TESLA, you need to generate some extra intermediate products during your\nbuild process. These products are:\n\n\n\n\nAssertions\n: the assertions you write about a program are parsed out and\n  written to external files in a structured format.\n\n\nManifest\n: assertions in one file can reference those written in other\n  files, so they need to be merged into one manifest file.\n\n\nLLVM IR\n: your code needs to be compiled to LLVM IR so that the TESLA tools\n  can analyse and modify it.\n\n\nInstrumented IR\n: the assertion manifest is used to add TESLA\n  instrumentation code to the compiled LLVM IR.\n\n\n\n\nA dependency graph between these products is shown in the graph below.\n\n\n\n\nToolchain\n\n\nTo generate TESLA intermediate products, you use the TESLA command-line tools.\nThese are:\n\n\n\n\ntesla analyse\n generates an assertion file (\n.tesla\n) from a C source file.\n\n\ntesla cat\n combines assertion files together into a manifest.\n\n\ntesla instrument\n uses a manifest to add instrumentation code to IR.\n\n\n\n\nYour C programs need to be compiled using \nclang\n 4.0. To generate LLVM IR from\na C source, use the flags \n-c -emit-llvm\n.\n\n\nExample\n\n\nIt\ns useful to work through a simple example to get a feel for the TESLA\ntoolchain and assertion language. The scenario we\nll consider here is a \nmutual\nexclusion lock\n, with the aim of preventing deadlock.\n\n\nThe example code in this guide can be found \nhere\n.\n\n\nSetup\n\n\nThe first step is to establish the data structures and operations we\nll be\nworking with. At its simplest, a mutual exclusion lock can be modelled by a\nstructure with a single boolean field:\n\n\n#include \nstdatomic.h\n\n#include \nstdbool.h\n\n\nstruct lock {\n  _Atomic(bool) held;\n};\n\n\n\n\nIf we have a lock, the only things we can do are to \nacquire\n or \nrelease\n it:\n\n\nbool lock_acquire(struct lock *l) {\n  bool f = false;\n  return atomic_compare_exchange_strong(\n(lock-\nheld), \nf, true);\n}\n\nvoid lock_release(struct lock *l) {\n  l-\nheld = false;\n}\n\n\n\n\nThese operations are thread safe (because they\nre written using the C11 atomics\nlibrary). If \nlock_acquire\n is called on a lock that\ns already held, it returns\n\nfalse\n. If we acquired the lock successfully, then it returns \ntrue\n.\n\n\nThe simplest possible program that uses the lock is:\n\n\nint main(void) {\n  struct lock *l = malloc(sizeof(*lock));\n\n  lock_acquire(l);\n  lock_release(l);\n\n  free(lock);\n  return 0;\n}\n\n\n\n\nBecause of limitations in the TESLA assertion parser, it can\nt currently work\nwith stack-allocated structures. Memory has to be dynamically allocated instead.\n\n\nA First Assertion\n\n\nTo prevent deadlock in code that uses these locks, the property we\nd like to\nassert is that a lock must eventually be released after it is acquired. The\nTESLA expression of this property is:\n\n\n#include \ntesla-macros.h\n\n\nbool lock_acquire(struct lock *l) {\n  TESLA_WITHIN(main, eventually(\n    call(lock_release(l))\n  ));\n\n  bool f = false;\n  return atomic_compare_exchange_strong(\n(lock-\nheld), \nf, true);\n}\n\n\n\n\nThere\ns quite a few things going on here. \nTESLA_WITHIN\n is the primary starting\npoint for TESLA assertions. Its first argument should be a function that acts as\na \nbounding context\n, and the second argument is a TESLA assertion.\n\n\nA bounding context limits the scope of an assertion. When the context function\nis called, TESLA performs internal initialisation (and cleanup when it returns).\nIn this example, the bounding context is \nmain\n. For small programs this is OK,\nbut for larger programs it can lead to performance issues. Generally speaking,\nit\ns best to use the narrowest bound possible for your assertions.\n\n\nThe assertion itself uses the \neventually\n macro, which states that the body of\nthe macro (\ncall(lock_release(l))\n) happens at some point \nafter\n the assertion\nsite (i.e. the location of \nTESLA_WITHIN(...)\n).\n\n\nAltogether, the assertion states that \nduring each execution of \nmain\n, if the\nassertion site is reached, \nlock_release\n is eventually called with \nl\n as its\nargument\n. Note that if the assertion site is not reached, then the assertion\ndoes not fail.\n\n\nWe can compile this first example using:\n\n\nclang -O0 -c -emit-llvm locks.c -o locks.bc\ntesla analyse locks.c -o locks.tesla --\ntesla instrument -tesla-manifest locks.tesla locks.bc -o locks.instr.bc\nclang locks.instr.bc -o locks\n\n\n\n\nRunning \n./locks\n will produce no output, as expected\nthe usage of the lock is\ncorrect. If you modify the body of \nmain\n to acquire but not release \nl\n, then\nrunning the compiled executable will produce a TESLA crash:\n\n\nTESLA failure:\nIn automaton 'locks.c:21#0':\nTESLA_WITHIN(main, eventually(\n    call(lock_release(l))\n  ));\nInstance 1 is in state 2\nbut received event '--(main() == X (Callee) \ncleanup\n)--\n('NFA:5')'\n(causes transition in: [ (1:0x0 -\n 3:0x0 \nclean\n) (4:0x1 -\n 3:0x0 \nclean\n) ])\n\nlocks: TESLA: failure in 'locks.c:21#0' --(main() == X (Callee) \ncleanup\n)--\n('NFA:5'): bad transition\n\n\n\n\nDebugging\n\n\nThe TESLA crash in the previous section is rather difficult to understand. We\ncan get a better picture of it by using \ntesla print\n to print out a DOT\nformatted version of the TESLA internal automaton:\n\n\ntesla print -d -format=dot locks.tesla\n\n\n\n\nThis produces output that looks like this:\n\n\n\n\nIt\ns still not the easiest to understand, but we can get a better idea of why\nthe assertion failed\nthe automaton was in state 2, but received the \nmain() cleanup\n event. From state 2, we can see that (as expected), instead of reaching\nthe end of \nmain\n, we should have called \nlock_release\n.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/programming/#programming-with-tesla", 
            "text": "This page walks you through how to use TESLA. It explains how TESLA is\nimplemented (and some associated terminology), how to use the toolchain, then\nhow to start writing useful assertions about your programs.", 
            "title": "Programming with TESLA"
        }, 
        {
            "location": "/programming/#tesla-basics", 
            "text": "TESLA is implemented as a set of tools that extend the traditional C compilation\nprocess. To write TESLA assertions, you need to add these tools to your\nbuild system and generate the TESLA intermediate products.", 
            "title": "TESLA Basics"
        }, 
        {
            "location": "/programming/#intermediate-products", 
            "text": "To use TESLA, you need to generate some extra intermediate products during your\nbuild process. These products are:   Assertions : the assertions you write about a program are parsed out and\n  written to external files in a structured format.  Manifest : assertions in one file can reference those written in other\n  files, so they need to be merged into one manifest file.  LLVM IR : your code needs to be compiled to LLVM IR so that the TESLA tools\n  can analyse and modify it.  Instrumented IR : the assertion manifest is used to add TESLA\n  instrumentation code to the compiled LLVM IR.   A dependency graph between these products is shown in the graph below.", 
            "title": "Intermediate Products"
        }, 
        {
            "location": "/programming/#toolchain", 
            "text": "To generate TESLA intermediate products, you use the TESLA command-line tools.\nThese are:   tesla analyse  generates an assertion file ( .tesla ) from a C source file.  tesla cat  combines assertion files together into a manifest.  tesla instrument  uses a manifest to add instrumentation code to IR.   Your C programs need to be compiled using  clang  4.0. To generate LLVM IR from\na C source, use the flags  -c -emit-llvm .", 
            "title": "Toolchain"
        }, 
        {
            "location": "/programming/#example", 
            "text": "It s useful to work through a simple example to get a feel for the TESLA\ntoolchain and assertion language. The scenario we ll consider here is a  mutual\nexclusion lock , with the aim of preventing deadlock.  The example code in this guide can be found  here .", 
            "title": "Example"
        }, 
        {
            "location": "/programming/#setup", 
            "text": "The first step is to establish the data structures and operations we ll be\nworking with. At its simplest, a mutual exclusion lock can be modelled by a\nstructure with a single boolean field:  #include  stdatomic.h \n#include  stdbool.h \n\nstruct lock {\n  _Atomic(bool) held;\n};  If we have a lock, the only things we can do are to  acquire  or  release  it:  bool lock_acquire(struct lock *l) {\n  bool f = false;\n  return atomic_compare_exchange_strong( (lock- held),  f, true);\n}\n\nvoid lock_release(struct lock *l) {\n  l- held = false;\n}  These operations are thread safe (because they re written using the C11 atomics\nlibrary). If  lock_acquire  is called on a lock that s already held, it returns false . If we acquired the lock successfully, then it returns  true .  The simplest possible program that uses the lock is:  int main(void) {\n  struct lock *l = malloc(sizeof(*lock));\n\n  lock_acquire(l);\n  lock_release(l);\n\n  free(lock);\n  return 0;\n}  Because of limitations in the TESLA assertion parser, it can t currently work\nwith stack-allocated structures. Memory has to be dynamically allocated instead.", 
            "title": "Setup"
        }, 
        {
            "location": "/programming/#a-first-assertion", 
            "text": "To prevent deadlock in code that uses these locks, the property we d like to\nassert is that a lock must eventually be released after it is acquired. The\nTESLA expression of this property is:  #include  tesla-macros.h \n\nbool lock_acquire(struct lock *l) {\n  TESLA_WITHIN(main, eventually(\n    call(lock_release(l))\n  ));\n\n  bool f = false;\n  return atomic_compare_exchange_strong( (lock- held),  f, true);\n}  There s quite a few things going on here.  TESLA_WITHIN  is the primary starting\npoint for TESLA assertions. Its first argument should be a function that acts as\na  bounding context , and the second argument is a TESLA assertion.  A bounding context limits the scope of an assertion. When the context function\nis called, TESLA performs internal initialisation (and cleanup when it returns).\nIn this example, the bounding context is  main . For small programs this is OK,\nbut for larger programs it can lead to performance issues. Generally speaking,\nit s best to use the narrowest bound possible for your assertions.  The assertion itself uses the  eventually  macro, which states that the body of\nthe macro ( call(lock_release(l)) ) happens at some point  after  the assertion\nsite (i.e. the location of  TESLA_WITHIN(...) ).  Altogether, the assertion states that  during each execution of  main , if the\nassertion site is reached,  lock_release  is eventually called with  l  as its\nargument . Note that if the assertion site is not reached, then the assertion\ndoes not fail.  We can compile this first example using:  clang -O0 -c -emit-llvm locks.c -o locks.bc\ntesla analyse locks.c -o locks.tesla --\ntesla instrument -tesla-manifest locks.tesla locks.bc -o locks.instr.bc\nclang locks.instr.bc -o locks  Running  ./locks  will produce no output, as expected the usage of the lock is\ncorrect. If you modify the body of  main  to acquire but not release  l , then\nrunning the compiled executable will produce a TESLA crash:  TESLA failure:\nIn automaton 'locks.c:21#0':\nTESLA_WITHIN(main, eventually(\n    call(lock_release(l))\n  ));\nInstance 1 is in state 2\nbut received event '--(main() == X (Callee)  cleanup )-- ('NFA:5')'\n(causes transition in: [ (1:0x0 -  3:0x0  clean ) (4:0x1 -  3:0x0  clean ) ])\n\nlocks: TESLA: failure in 'locks.c:21#0' --(main() == X (Callee)  cleanup )-- ('NFA:5'): bad transition", 
            "title": "A First Assertion"
        }, 
        {
            "location": "/programming/#debugging", 
            "text": "The TESLA crash in the previous section is rather difficult to understand. We\ncan get a better picture of it by using  tesla print  to print out a DOT\nformatted version of the TESLA internal automaton:  tesla print -d -format=dot locks.tesla  This produces output that looks like this:   It s still not the easiest to understand, but we can get a better idea of why\nthe assertion failed the automaton was in state 2, but received the  main() cleanup  event. From state 2, we can see that (as expected), instead of reaching\nthe end of  main , we should have called  lock_release .", 
            "title": "Debugging"
        }, 
        {
            "location": "/macros/", 
            "text": "TESLA Macro Reference\n\n\nThis page provides a full reference to the TESLA assertion language and the\nconvenience macros provided to use it. All the macros documented on this page\nare available in \ntesla-macros.h\n.\n\n\nAssertion Site Declarations\n\n\nTESLA_ASSERT\n\n\nTESLA_GLOBAL\n\n\nTESLA_PERTHREAD\n\n\nTESLA_WITHIN\n\n\nTemporal Assertions\n\n\nTESLA_ASSERTION_SITE\n\n\nTIGNORE\n\n\nTSEQUENCE\n\n\ncall\n\n\neventually\n\n\npreviously\n\n\nreturnfrom\n\n\nModifiers\n\n\nANY\n\n\nbitmask\n\n\ncallee\n\n\ncaller\n\n\nconditional\n\n\noptional\n\n\nstrict\n\n\nflags\n\n\nSequences\n\n\nANY_REP\n\n\nATLEAST\n\n\nREPEAT\n\n\nUPTO\n\n\nExplicit Automata\n\n\nTESLA_STRUCT_AUTOMATON\n\n\ntesla_done\n\n\nautomaton", 
            "title": "Macro Reference"
        }, 
        {
            "location": "/macros/#tesla-macro-reference", 
            "text": "This page provides a full reference to the TESLA assertion language and the\nconvenience macros provided to use it. All the macros documented on this page\nare available in  tesla-macros.h .", 
            "title": "TESLA Macro Reference"
        }, 
        {
            "location": "/macros/#assertion-site-declarations", 
            "text": "", 
            "title": "Assertion Site Declarations"
        }, 
        {
            "location": "/macros/#tesla_assert", 
            "text": "", 
            "title": "TESLA_ASSERT"
        }, 
        {
            "location": "/macros/#tesla_global", 
            "text": "", 
            "title": "TESLA_GLOBAL"
        }, 
        {
            "location": "/macros/#tesla_perthread", 
            "text": "", 
            "title": "TESLA_PERTHREAD"
        }, 
        {
            "location": "/macros/#tesla_within", 
            "text": "", 
            "title": "TESLA_WITHIN"
        }, 
        {
            "location": "/macros/#temporal-assertions", 
            "text": "", 
            "title": "Temporal Assertions"
        }, 
        {
            "location": "/macros/#tesla_assertion_site", 
            "text": "", 
            "title": "TESLA_ASSERTION_SITE"
        }, 
        {
            "location": "/macros/#tignore", 
            "text": "", 
            "title": "TIGNORE"
        }, 
        {
            "location": "/macros/#tsequence", 
            "text": "", 
            "title": "TSEQUENCE"
        }, 
        {
            "location": "/macros/#call", 
            "text": "", 
            "title": "call"
        }, 
        {
            "location": "/macros/#eventually", 
            "text": "", 
            "title": "eventually"
        }, 
        {
            "location": "/macros/#previously", 
            "text": "", 
            "title": "previously"
        }, 
        {
            "location": "/macros/#returnfrom", 
            "text": "", 
            "title": "returnfrom"
        }, 
        {
            "location": "/macros/#modifiers", 
            "text": "", 
            "title": "Modifiers"
        }, 
        {
            "location": "/macros/#any", 
            "text": "", 
            "title": "ANY"
        }, 
        {
            "location": "/macros/#bitmask", 
            "text": "", 
            "title": "bitmask"
        }, 
        {
            "location": "/macros/#callee", 
            "text": "", 
            "title": "callee"
        }, 
        {
            "location": "/macros/#caller", 
            "text": "", 
            "title": "caller"
        }, 
        {
            "location": "/macros/#conditional", 
            "text": "", 
            "title": "conditional"
        }, 
        {
            "location": "/macros/#optional", 
            "text": "", 
            "title": "optional"
        }, 
        {
            "location": "/macros/#strict", 
            "text": "", 
            "title": "strict"
        }, 
        {
            "location": "/macros/#flags", 
            "text": "", 
            "title": "flags"
        }, 
        {
            "location": "/macros/#sequences", 
            "text": "", 
            "title": "Sequences"
        }, 
        {
            "location": "/macros/#any_rep", 
            "text": "", 
            "title": "ANY_REP"
        }, 
        {
            "location": "/macros/#atleast", 
            "text": "", 
            "title": "ATLEAST"
        }, 
        {
            "location": "/macros/#repeat", 
            "text": "", 
            "title": "REPEAT"
        }, 
        {
            "location": "/macros/#upto", 
            "text": "", 
            "title": "UPTO"
        }, 
        {
            "location": "/macros/#explicit-automata", 
            "text": "", 
            "title": "Explicit Automata"
        }, 
        {
            "location": "/macros/#tesla_struct_automaton", 
            "text": "", 
            "title": "TESLA_STRUCT_AUTOMATON"
        }, 
        {
            "location": "/macros/#tesla_done", 
            "text": "", 
            "title": "tesla_done"
        }, 
        {
            "location": "/macros/#automaton", 
            "text": "", 
            "title": "automaton"
        }, 
        {
            "location": "/static/", 
            "text": "Static Analysis\n\n\nThere is ongoing work on proving TESLA assertions at compile time. When this\nwork is \nproduction ready\n, documentation on using it will be added to this\npage. Preliminary results are promising, indicating potentially significant\nperformance improvements.", 
            "title": "Static Analysis"
        }, 
        {
            "location": "/static/#static-analysis", 
            "text": "There is ongoing work on proving TESLA assertions at compile time. When this\nwork is  production ready , documentation on using it will be added to this\npage. Preliminary results are promising, indicating potentially significant\nperformance improvements.", 
            "title": "Static Analysis"
        }, 
        {
            "location": "/commands/", 
            "text": "TESLA Commands\n\n\nanalyse\n\n\nSummary\n\n\nExtracts TESLA assertions from a program and output them to an assertion manifest\nfile. Takes a single C source file as an argument, and produces a TESLA\nassertion file in either binary or textual format.\n\n\nBecause \ntesla analyse\n is implemented as a \nClang tool\n, it needs\nto be given the compilation options for the file it\ns analysing (so that it can\nproperly handle preprocessor definitions and other program features). Currently,\nthese options need to be given at the command line\nusing\n\ncompile_commands.json\n is not yet supported.\n\n\nUsage\n\n\ntesla analyse [options] \nsource\n -o \noutput\n -- [compilation options]\n\n\n\n\nNote that even if your code has no specific command line options, you must still\nterminate the list of arguments to \ntesla analyse\n with \n--\n.\n\n\nOptions\n\n\n\n\n-S\n: generate textual TESLA output (rather than binary) for debugging\n  purposes.\n\n\n\n\ncat\n\n\nSummary\n\n\nCombine multiple TESLA assertion files together into a single file for\ninstrumentation.\n\n\nTakes all the assertion files as positional arguments, and a single output file\nas a named argument. If no output is specified, the resulting assertion manifest\nis output on \nstdout\n. The output of \ntesla cat\n is always a textual manifest\n(rather than binary).\n\n\nBecause each source file produces its own assertion file, which can reference\nautomata defined in other files, we need to combine them together (while also\nchecking for consistency\nif two files both define an automata, the definitions\nneed to be the same).\n\n\nUsage\n\n\ntesla cat \ninput ...\n -o \noutput\n\n\n\n\n\ninstrument\n\n\nSummary\n\n\nAdd TESLA instrumentation code to LLVM IR.\n\n\nThe assertion code to be added is generated from a TESLA assertion manifest, and\nreplaces instrumentation hooks.\n\n\nUsage\n\n\ntesla instrument -tesla-manifest \nmanifest\n \nIR file\n -o \noutput\n\n\n\n\n\nOptions\n\n\n\n\n-S\n: print textual LLVM IR instead of binary. If this is specified, then \n-o\n\n  can be omitted and the output will go to \nstdout\n.\n\n\n\n\nprint\n\n\nSummary\n\n\nPrint TESLA automata information from an assertion manifest.\n\n\nSupports multiple formats for the printed information.\n\n\nUsage\n\n\ntesla print [options] \ninput file\n\n\n\n\n\nOptions\n\n\n\n\nOutput formats (\n-format=\n):\n\n\ndot\n: GraphViz dot\n\n\ninstr\n: instrumentation points\n\n\nnames\n: automata names\n\n\nsource\n: automata definitions from the original source code\n\n\nsummary\n: succinct summaries\n\n\ntext\n: textual automata representations\n\n\n\n\n\n\nAutomata determinism:\n\n\n-r\n: raw (unlinked) NFA\n\n\n-n\n: NFA\n\n\n-d\n: DFA\n\n\n\n\n\n\n\n\nstatic\n\n\nSummary\n\n\nPerform static analysis on an assertion manifest, producing a new manifest with\nsafe assertions deleted.\n\n\nUsage\n\n\ntesla static [options] \nmanifest\n \nIR\n -o \noutput\n\n\n\n\n\nOptions\n\n\n\n\nPass selection:\n\n\n-mc\n: Run the TESLA model checker.\n\n\n\n\n\n\nModel checker options:\n\n\n-bound=\nint\n: set the maximum length of finite traces to examine\n  (measured in the number of basic blocks).\n\n\n-unroll=\nint\n: set the maximum function call inlining depth. If your\n  call graph is deeper than this value, information can be lost at the\n  inlining phase.\n\n\n-mem2reg\n: run the LLVM memory to register promotion pass before the\n  model checker. This can make the checker run a lot faster, but loses\n  information about variable names. Some assertions will be incorrectly\n  marked as unsafe if using this option.", 
            "title": "Command Reference"
        }, 
        {
            "location": "/commands/#tesla-commands", 
            "text": "", 
            "title": "TESLA Commands"
        }, 
        {
            "location": "/commands/#analyse", 
            "text": "", 
            "title": "analyse"
        }, 
        {
            "location": "/commands/#summary", 
            "text": "Extracts TESLA assertions from a program and output them to an assertion manifest\nfile. Takes a single C source file as an argument, and produces a TESLA\nassertion file in either binary or textual format.  Because  tesla analyse  is implemented as a  Clang tool , it needs\nto be given the compilation options for the file it s analysing (so that it can\nproperly handle preprocessor definitions and other program features). Currently,\nthese options need to be given at the command line using compile_commands.json  is not yet supported.", 
            "title": "Summary"
        }, 
        {
            "location": "/commands/#usage", 
            "text": "tesla analyse [options]  source  -o  output  -- [compilation options]  Note that even if your code has no specific command line options, you must still\nterminate the list of arguments to  tesla analyse  with  -- .", 
            "title": "Usage"
        }, 
        {
            "location": "/commands/#options", 
            "text": "-S : generate textual TESLA output (rather than binary) for debugging\n  purposes.", 
            "title": "Options"
        }, 
        {
            "location": "/commands/#cat", 
            "text": "", 
            "title": "cat"
        }, 
        {
            "location": "/commands/#summary_1", 
            "text": "Combine multiple TESLA assertion files together into a single file for\ninstrumentation.  Takes all the assertion files as positional arguments, and a single output file\nas a named argument. If no output is specified, the resulting assertion manifest\nis output on  stdout . The output of  tesla cat  is always a textual manifest\n(rather than binary).  Because each source file produces its own assertion file, which can reference\nautomata defined in other files, we need to combine them together (while also\nchecking for consistency if two files both define an automata, the definitions\nneed to be the same).", 
            "title": "Summary"
        }, 
        {
            "location": "/commands/#usage_1", 
            "text": "tesla cat  input ...  -o  output", 
            "title": "Usage"
        }, 
        {
            "location": "/commands/#instrument", 
            "text": "", 
            "title": "instrument"
        }, 
        {
            "location": "/commands/#summary_2", 
            "text": "Add TESLA instrumentation code to LLVM IR.  The assertion code to be added is generated from a TESLA assertion manifest, and\nreplaces instrumentation hooks.", 
            "title": "Summary"
        }, 
        {
            "location": "/commands/#usage_2", 
            "text": "tesla instrument -tesla-manifest  manifest   IR file  -o  output", 
            "title": "Usage"
        }, 
        {
            "location": "/commands/#options_1", 
            "text": "-S : print textual LLVM IR instead of binary. If this is specified, then  -o \n  can be omitted and the output will go to  stdout .", 
            "title": "Options"
        }, 
        {
            "location": "/commands/#print", 
            "text": "", 
            "title": "print"
        }, 
        {
            "location": "/commands/#summary_3", 
            "text": "Print TESLA automata information from an assertion manifest.  Supports multiple formats for the printed information.", 
            "title": "Summary"
        }, 
        {
            "location": "/commands/#usage_3", 
            "text": "tesla print [options]  input file", 
            "title": "Usage"
        }, 
        {
            "location": "/commands/#options_2", 
            "text": "Output formats ( -format= ):  dot : GraphViz dot  instr : instrumentation points  names : automata names  source : automata definitions from the original source code  summary : succinct summaries  text : textual automata representations    Automata determinism:  -r : raw (unlinked) NFA  -n : NFA  -d : DFA", 
            "title": "Options"
        }, 
        {
            "location": "/commands/#static", 
            "text": "", 
            "title": "static"
        }, 
        {
            "location": "/commands/#summary_4", 
            "text": "Perform static analysis on an assertion manifest, producing a new manifest with\nsafe assertions deleted.", 
            "title": "Summary"
        }, 
        {
            "location": "/commands/#usage_4", 
            "text": "tesla static [options]  manifest   IR  -o  output", 
            "title": "Usage"
        }, 
        {
            "location": "/commands/#options_3", 
            "text": "Pass selection:  -mc : Run the TESLA model checker.    Model checker options:  -bound= int : set the maximum length of finite traces to examine\n  (measured in the number of basic blocks).  -unroll= int : set the maximum function call inlining depth. If your\n  call graph is deeper than this value, information can be lost at the\n  inlining phase.  -mem2reg : run the LLVM memory to register promotion pass before the\n  model checker. This can make the checker run a lot faster, but loses\n  information about variable names. Some assertions will be incorrectly\n  marked as unsafe if using this option.", 
            "title": "Options"
        }
    ]
}
{
    "docs": [
        {
            "location": "/", 
            "text": "TESLA\n\n\nTESLA allows you to make \ntemporal assertions\n about your programs. Instead of\nbeing limited to its current state, you can make assertions about its \npast\n and\n\nfuture\n as well\nletting you write safer programs as naturally as possible.\n\n\nWith TESLA, you can make assertions like \nThe function \naccess_control_check\n\nreturned \n0\n before reading a file\n or \nThe structure field \nlock-\nheld\n is set\nto \nfalse\n in the future\n. In normal programs, these properties are often\nasserted informally or not at all. With TESLA, they can be checked automatically\nat compile- or run-time.\n\n\nExamples\n\n\nchar *read_sensitive_data() {\n  TESLA_WITHIN(main, previously(\n    access_control_check() == 0\n  ));\n\n  char *data;\n  // perform sensitive data access\n  return data;\n}\n\n\n\n\nvoid critical_section_begin(lock_t *lock) {\n  TESLA_WITHIN(main, eventually(\n    lock-\nheld = false\n  ));\n\n  // do locked critical section work\n}\n\n\n\n\nSetup\n\n\nSee the \ninstallation guide\n for instructions on getting set up\nwith TESLA. Once you\nve got it up and running, the \nprogramming\nguide\n walks you through how to write a program with TESLA\nassertions.\n\n\nPublications\n\n\n\n\nTESLA: Temporally Enhanced System Logic Assertions\n\n\nStatic Analysis for TESLA (\nupcoming\n)", 
            "title": "Home"
        }, 
        {
            "location": "/#tesla", 
            "text": "TESLA allows you to make  temporal assertions  about your programs. Instead of\nbeing limited to its current state, you can make assertions about its  past  and future  as well letting you write safer programs as naturally as possible.  With TESLA, you can make assertions like  The function  access_control_check \nreturned  0  before reading a file  or  The structure field  lock- held  is set\nto  false  in the future . In normal programs, these properties are often\nasserted informally or not at all. With TESLA, they can be checked automatically\nat compile- or run-time.", 
            "title": "TESLA"
        }, 
        {
            "location": "/#examples", 
            "text": "char *read_sensitive_data() {\n  TESLA_WITHIN(main, previously(\n    access_control_check() == 0\n  ));\n\n  char *data;\n  // perform sensitive data access\n  return data;\n}  void critical_section_begin(lock_t *lock) {\n  TESLA_WITHIN(main, eventually(\n    lock- held = false\n  ));\n\n  // do locked critical section work\n}", 
            "title": "Examples"
        }, 
        {
            "location": "/#setup", 
            "text": "See the  installation guide  for instructions on getting set up\nwith TESLA. Once you ve got it up and running, the  programming\nguide  walks you through how to write a program with TESLA\nassertions.", 
            "title": "Setup"
        }, 
        {
            "location": "/#publications", 
            "text": "TESLA: Temporally Enhanced System Logic Assertions  Static Analysis for TESLA ( upcoming )", 
            "title": "Publications"
        }, 
        {
            "location": "/installation/", 
            "text": "Installing TESLA\n\n\nCurrently TESLA has to be built from source (though package manager\ndistributions are in the works).\n\n\nDependencies\n\n\nTo build TESLA, you need:\n\n\n\n\nBuild system:\n\n\nCMake\n\n\nA C++14 compatible compiler (GCC 5+ or Clang 3.4+)\n\n\n\n\n\n\nTESLA dependencies:\n\n\nLLVM 4.0\n\n\nProtocol Buffers\n\n\nZ3\n\n\n\n\n\n\n\n\nThe TESLA dependencies don\nt need to be installed from source\nyou can get them\nfrom a package manager if that\ns easier.\n\n\nBuild Instructions\n\n\nOnce you\nve installed the dependencies, you can build TESLA as follows:\n\n\ngit clone \nhttp://github.com/cadets/tesla-static-analysis\n\ncd tesla-static-analysis\n\nmkdir build\ncd build\n\ncmake -D LLVM_DIR=\npath/to/llvm\n ..\nmake\nmake install\n\n\n\n\nThe CMake option \nLLVM_DIR\n should point to the directory where LLVM has\ninstalled its CMake files. This will typically be the \nlib/cmake/llvm/\n\nsubdirectory of the LLVM install directory.\n\n\nTo install TESLA to a non-standard location, set \nCMAKE_INSTALL_PREFIX\n and run\n\nmake install\n.\n\n\nOnce you have TESLA installed, you should be able to run \ntesla\n to see a list\nof the available toolchain commands. The next step is to \nwrite some TESLA\nassertions\n.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installing-tesla", 
            "text": "Currently TESLA has to be built from source (though package manager\ndistributions are in the works).", 
            "title": "Installing TESLA"
        }, 
        {
            "location": "/installation/#dependencies", 
            "text": "To build TESLA, you need:   Build system:  CMake  A C++14 compatible compiler (GCC 5+ or Clang 3.4+)    TESLA dependencies:  LLVM 4.0  Protocol Buffers  Z3     The TESLA dependencies don t need to be installed from source you can get them\nfrom a package manager if that s easier.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/installation/#build-instructions", 
            "text": "Once you ve installed the dependencies, you can build TESLA as follows:  git clone  http://github.com/cadets/tesla-static-analysis \ncd tesla-static-analysis\n\nmkdir build\ncd build\n\ncmake -D LLVM_DIR= path/to/llvm  ..\nmake\nmake install  The CMake option  LLVM_DIR  should point to the directory where LLVM has\ninstalled its CMake files. This will typically be the  lib/cmake/llvm/ \nsubdirectory of the LLVM install directory.  To install TESLA to a non-standard location, set  CMAKE_INSTALL_PREFIX  and run make install .  Once you have TESLA installed, you should be able to run  tesla  to see a list\nof the available toolchain commands. The next step is to  write some TESLA\nassertions .", 
            "title": "Build Instructions"
        }, 
        {
            "location": "/programming/", 
            "text": "Programming with TESLA\n\n\nThis page walks you through how to use TESLA. It explains how TESLA is\nimplemented (and some associated terminology), how to use the toolchain, then\nhow to start writing useful assertions about your programs.\n\n\nTESLA Basics\n\n\nTESLA is implemented as a set of tools that extend the traditional C compilation\nprocess. To write TESLA assertions, you need to add these tools to your\nbuild system and generate the TESLA intermediate products.\n\n\nIntermediate Products\n\n\nTo use TESLA, you need to generate some extra intermediate products during your\nbuild process. These products are:\n\n\n\n\nAssertions\n: the assertions you write about a program are parsed out and\n  written to external files in a structured format.\n\n\nManifest\n: assertions in one file can reference those written in other\n  files, so they need to be merged into one manifest file.\n\n\nLLVM IR\n: your code needs to be compiled to LLVM IR so that the TESLA tools\n  can analyse and modify it.\n\n\nInstrumented IR\n: the assertion manifest is used to add TESLA\n  instrumentation code to the compiled LLVM IR.\n\n\n\n\nA dependency graph between these products is shown in the graph below.\n\n\n\n\nToolchain\n\n\nTo generate TESLA intermediate products, you use the TESLA command-line tools.\nThese are:\n\n\n\n\ntesla analyse\n generates an assertion file (\n.tesla\n) from a C source file.\n\n\ntesla cat\n combines assertion files together into a manifest.\n\n\ntesla instrument\n uses a manifest to add instrumentation code to IR.\n\n\n\n\nYour C programs need to be compiled using \nclang\n 4.0. To generate LLVM IR from\na C source, use the flags \n-c -emit-llvm\n.\n\n\nExample\n\n\nIt\ns useful to work through a simple example to get a feel for the TESLA\ntoolchain and assertion language. The scenario we\nll consider here is a \nmutual\nexclusion lock\n, with the aim of preventing deadlock.\n\n\nThe example code in this guide can be found \nhere\n.\n\n\nSetup\n\n\nThe first step is to establish the data structures and operations we\nll be\nworking with. At its simplest, a mutual exclusion lock can be modelled by a\nstructure with a single boolean field:\n\n\n#include \nstdatomic.h\n\n#include \nstdbool.h\n\n\nstruct lock {\n  _Atomic(bool) held;\n};\n\n\n\n\nIf we have a lock, the only things we can do are to \nacquire\n or \nrelease\n it:\n\n\nbool lock_acquire(struct lock *l) {\n  bool f = false;\n  return atomic_compare_exchange_strong(\n(lock-\nheld), \nf, true);\n}\n\nvoid lock_release(struct lock *l) {\n  l-\nheld = false;\n}\n\n\n\n\nThese operations are thread safe (because they\nre written using the C11 atomics\nlibrary). If \nlock_acquire\n is called on a lock that\ns already held, it returns\n\nfalse\n. If we acquired the lock successfully, then it returns \ntrue\n.\n\n\nThe simplest possible program that uses the lock is:\n\n\nint main(void) {\n  struct lock *l = malloc(sizeof(*lock));\n\n  lock_acquire(l);\n  lock_release(l);\n\n  free(lock);\n  return 0;\n}\n\n\n\n\nBecause of limitations in the TESLA assertion parser, it can\nt currently work\nwith stack-allocated structures. Memory has to be dynamically allocated instead.\n\n\nA First Assertion\n\n\nTo prevent deadlock in code that uses these locks, the property we\nd like to\nassert is that a lock must eventually be released after it is acquired. The\nTESLA expression of this property is:\n\n\n#include \ntesla-macros.h\n\n\nbool lock_acquire(struct lock *l) {\n  TESLA_WITHIN(main, eventually(\n    call(lock_release(l))\n  ));\n\n  bool f = false;\n  return atomic_compare_exchange_strong(\n(lock-\nheld), \nf, true);\n}\n\n\n\n\nThere\ns quite a few things going on here. \nTESLA_WITHIN\n is the primary starting\npoint for TESLA assertions. Its first argument should be a function that acts as\na \nbounding context\n, and the second argument is a TESLA assertion.\n\n\nA bounding context limits the scope of an assertion. When the context function\nis called, TESLA performs internal initialisation (and cleanup when it returns).\nIn this example, the bounding context is \nmain\n. For small programs this is OK,\nbut for larger programs it can lead to performance issues. Generally speaking,\nit\ns best to use the narrowest bound possible for your assertions.\n\n\nThe assertion itself uses the \neventually\n macro, which states that the body of\nthe macro (\ncall(lock_release(l))\n) happens at some point \nafter\n the assertion\nsite (i.e. the location of \nTESLA_WITHIN(...)\n).\n\n\nAltogether, the assertion states that \nduring each execution of \nmain\n, if the\nassertion site is reached, \nlock_release\n is eventually called with \nl\n as its\nargument\n. Note that if the assertion site is not reached, then the assertion\ndoes not fail.\n\n\nWe can compile this first example using:\n\n\nclang -O0 -c -emit-llvm locks.c -o locks.bc\ntesla analyse locks.c -o locks.tesla --\ntesla instrument -tesla-manifest locks.tesla locks.bc -o locks.instr.bc\nclang locks.instr.bc -o locks\n\n\n\n\nRunning \n./locks\n will produce no output, as expected\nthe usage of the lock is\ncorrect. If you modify the body of \nmain\n to acquire but not release \nl\n, then\nrunning the compiled executable will produce a TESLA crash:\n\n\nTESLA failure:\nIn automaton 'locks.c:21#0':\nTESLA_WITHIN(main, eventually(\n    call(lock_release(l))\n  ));\nInstance 1 is in state 2\nbut received event '--(main() == X (Callee) \ncleanup\n)--\n('NFA:5')'\n(causes transition in: [ (1:0x0 -\n 3:0x0 \nclean\n) (4:0x1 -\n 3:0x0 \nclean\n) ])\n\nlocks: TESLA: failure in 'locks.c:21#0' --(main() == X (Callee) \ncleanup\n)--\n('NFA:5'): bad transition\n\n\n\n\nDebugging\n\n\nThe TESLA crash in the previous section is rather difficult to understand. We\ncan get a better picture of it by using \ntesla print\n to print out a DOT\nformatted version of the TESLA internal automaton:\n\n\ntesla print -d -format=dot locks.tesla\n\n\n\n\nThis produces output that looks like this:\n\n\n\n\nIt\ns still not the easiest to understand, but we can get a better idea of why\nthe assertion failed\nthe automaton was in state 2, but received the \nmain() cleanup\n event. From state 2, we can see that (as expected), instead of reaching\nthe end of \nmain\n, we should have called \nlock_release\n.", 
            "title": "Programming"
        }, 
        {
            "location": "/programming/#programming-with-tesla", 
            "text": "This page walks you through how to use TESLA. It explains how TESLA is\nimplemented (and some associated terminology), how to use the toolchain, then\nhow to start writing useful assertions about your programs.", 
            "title": "Programming with TESLA"
        }, 
        {
            "location": "/programming/#tesla-basics", 
            "text": "TESLA is implemented as a set of tools that extend the traditional C compilation\nprocess. To write TESLA assertions, you need to add these tools to your\nbuild system and generate the TESLA intermediate products.", 
            "title": "TESLA Basics"
        }, 
        {
            "location": "/programming/#intermediate-products", 
            "text": "To use TESLA, you need to generate some extra intermediate products during your\nbuild process. These products are:   Assertions : the assertions you write about a program are parsed out and\n  written to external files in a structured format.  Manifest : assertions in one file can reference those written in other\n  files, so they need to be merged into one manifest file.  LLVM IR : your code needs to be compiled to LLVM IR so that the TESLA tools\n  can analyse and modify it.  Instrumented IR : the assertion manifest is used to add TESLA\n  instrumentation code to the compiled LLVM IR.   A dependency graph between these products is shown in the graph below.", 
            "title": "Intermediate Products"
        }, 
        {
            "location": "/programming/#toolchain", 
            "text": "To generate TESLA intermediate products, you use the TESLA command-line tools.\nThese are:   tesla analyse  generates an assertion file ( .tesla ) from a C source file.  tesla cat  combines assertion files together into a manifest.  tesla instrument  uses a manifest to add instrumentation code to IR.   Your C programs need to be compiled using  clang  4.0. To generate LLVM IR from\na C source, use the flags  -c -emit-llvm .", 
            "title": "Toolchain"
        }, 
        {
            "location": "/programming/#example", 
            "text": "It s useful to work through a simple example to get a feel for the TESLA\ntoolchain and assertion language. The scenario we ll consider here is a  mutual\nexclusion lock , with the aim of preventing deadlock.  The example code in this guide can be found  here .", 
            "title": "Example"
        }, 
        {
            "location": "/programming/#setup", 
            "text": "The first step is to establish the data structures and operations we ll be\nworking with. At its simplest, a mutual exclusion lock can be modelled by a\nstructure with a single boolean field:  #include  stdatomic.h \n#include  stdbool.h \n\nstruct lock {\n  _Atomic(bool) held;\n};  If we have a lock, the only things we can do are to  acquire  or  release  it:  bool lock_acquire(struct lock *l) {\n  bool f = false;\n  return atomic_compare_exchange_strong( (lock- held),  f, true);\n}\n\nvoid lock_release(struct lock *l) {\n  l- held = false;\n}  These operations are thread safe (because they re written using the C11 atomics\nlibrary). If  lock_acquire  is called on a lock that s already held, it returns false . If we acquired the lock successfully, then it returns  true .  The simplest possible program that uses the lock is:  int main(void) {\n  struct lock *l = malloc(sizeof(*lock));\n\n  lock_acquire(l);\n  lock_release(l);\n\n  free(lock);\n  return 0;\n}  Because of limitations in the TESLA assertion parser, it can t currently work\nwith stack-allocated structures. Memory has to be dynamically allocated instead.", 
            "title": "Setup"
        }, 
        {
            "location": "/programming/#a-first-assertion", 
            "text": "To prevent deadlock in code that uses these locks, the property we d like to\nassert is that a lock must eventually be released after it is acquired. The\nTESLA expression of this property is:  #include  tesla-macros.h \n\nbool lock_acquire(struct lock *l) {\n  TESLA_WITHIN(main, eventually(\n    call(lock_release(l))\n  ));\n\n  bool f = false;\n  return atomic_compare_exchange_strong( (lock- held),  f, true);\n}  There s quite a few things going on here.  TESLA_WITHIN  is the primary starting\npoint for TESLA assertions. Its first argument should be a function that acts as\na  bounding context , and the second argument is a TESLA assertion.  A bounding context limits the scope of an assertion. When the context function\nis called, TESLA performs internal initialisation (and cleanup when it returns).\nIn this example, the bounding context is  main . For small programs this is OK,\nbut for larger programs it can lead to performance issues. Generally speaking,\nit s best to use the narrowest bound possible for your assertions.  The assertion itself uses the  eventually  macro, which states that the body of\nthe macro ( call(lock_release(l)) ) happens at some point  after  the assertion\nsite (i.e. the location of  TESLA_WITHIN(...) ).  Altogether, the assertion states that  during each execution of  main , if the\nassertion site is reached,  lock_release  is eventually called with  l  as its\nargument . Note that if the assertion site is not reached, then the assertion\ndoes not fail.  We can compile this first example using:  clang -O0 -c -emit-llvm locks.c -o locks.bc\ntesla analyse locks.c -o locks.tesla --\ntesla instrument -tesla-manifest locks.tesla locks.bc -o locks.instr.bc\nclang locks.instr.bc -o locks  Running  ./locks  will produce no output, as expected the usage of the lock is\ncorrect. If you modify the body of  main  to acquire but not release  l , then\nrunning the compiled executable will produce a TESLA crash:  TESLA failure:\nIn automaton 'locks.c:21#0':\nTESLA_WITHIN(main, eventually(\n    call(lock_release(l))\n  ));\nInstance 1 is in state 2\nbut received event '--(main() == X (Callee)  cleanup )-- ('NFA:5')'\n(causes transition in: [ (1:0x0 -  3:0x0  clean ) (4:0x1 -  3:0x0  clean ) ])\n\nlocks: TESLA: failure in 'locks.c:21#0' --(main() == X (Callee)  cleanup )-- ('NFA:5'): bad transition", 
            "title": "A First Assertion"
        }, 
        {
            "location": "/programming/#debugging", 
            "text": "The TESLA crash in the previous section is rather difficult to understand. We\ncan get a better picture of it by using  tesla print  to print out a DOT\nformatted version of the TESLA internal automaton:  tesla print -d -format=dot locks.tesla  This produces output that looks like this:   It s still not the easiest to understand, but we can get a better idea of why\nthe assertion failed the automaton was in state 2, but received the  main() cleanup  event. From state 2, we can see that (as expected), instead of reaching\nthe end of  main , we should have called  lock_release .", 
            "title": "Debugging"
        }
    ]
}